var test = require('prova');
var vom = require('vom');
var ifaceSigType = require(
  '../../src/v.io/core/veyron2/vdl/vdlroot/src/signature/signature'
).Interface;

test('import paths work', function(assert) {
  // We just need to require the arith package to make sure that
  // require calls in the arith package is exercised. For now
  // we don't have anything interesting to actually check about the
  // result. This file is generated by the vdl tool.
  assert.doesNotThrow(function() {
    require(
      '../../src/v.io/core/veyron2/vdl/testdata/arith/arith');
  });
  assert.end();
});

test('method signature encode-decode match', function(assert) {
  var arith = require(
    '../../src/v.io/core/veyron2/vdl/testdata/arith/arith');

  var writer;
  var encoder;
  var reader;
  var decoder;
  var sigEncode;
  var sigDecode;

  // For every service signature defined...
  var serviceNames = ['Arith', 'Calculator'];
  serviceNames.forEach(function(serviceName) {
    if (!arith.hasOwnProperty(serviceName)) {
      assert.fail('Expected interface ' + serviceName + ' to be defined');
      return;
    }
    var signature = arith.AdvancedMath.prototype.
                    _serviceDescription;

    // Encode the signature using the type defined in VDL-generated ipc.js
    writer = new vom.ByteArrayMessageWriter();
    encoder = new vom.Encoder(writer);
    encoder.encode(signature, ifaceSigType.prototype._type);
    sigEncode = writer.getBytes();

    // Decode the signature.
    reader = new vom.ByteArrayMessageReader(sigEncode);
    decoder = new vom.Decoder(reader);
    sigDecode = decoder.decode();

    // Ensure that what was decoded matches the original signature deeply.
    assert.deepEqual(sigDecode, signature, serviceName + ' signature match');

    // TODO The signature type should be attached to the generated signature
    // This is currently problematic (Issue 432), so manually attaching type
    // for now and NOT passing the type into the encoder.
    var wrappedSignature = new ifaceSigType(signature);

    // Encode the signature as a wrapped struct.
    writer = new vom.ByteArrayMessageWriter();
    encoder = new vom.Encoder(writer);
    encoder.encode(wrappedSignature);
    sigEncode = writer.getBytes();

    // Decode the signature.
    reader = new vom.ByteArrayMessageReader(sigEncode);
    decoder = new vom.Decoder(reader);
    sigDecode = decoder.decode();

    assert.deepEqual(sigDecode, wrappedSignature, serviceName +
      ' wrapped signature match');
  });
  assert.end();
});

var _type1 = new vom.Type();
var _type2 = new vom.Type();
var _type3 = new vom.Type();
var _typeerror = new vom.Type();
_type1.kind = vom.Kind.NILABLE;
_type1.name = '';
_type1.elem = _typeerror;
_type2.kind = vom.Kind.STRUCT;
_type2.name = '';
_type2.fields = [{name: 'ID', type: vom.Types.STRING},
  {name: 'Action', type: vom.Types.UINT32}];
_type3.kind = vom.Kind.LIST;
_type3.name = '';
_type3.elem = vom.Types.ANY;
_typeerror.kind = vom.Kind.STRUCT;
_typeerror.name = 'error';
_typeerror.fields = [{name: 'IDAction', type: _type2},
  {name: 'Msg', type: vom.Types.STRING}, {name: 'ParamList', type: _type3}];
module.exports.error = vom.Registry.lookupOrCreateConstructor(
  _typeerror, 'error');

var expectedAdvancedMathDescription = {
  name: 'AdvancedMath',
  pkgPath: 'v.io/core/veyron2/vdl/testdata/arith',
  doc: '// AdvancedMath is an interface for more advanced math than arith.  ' +
  'It embeds\n// interfaces defined both in the same file and in an external ' +
  'package; and in\n// turn it is embedded by arith.Calculator (which is in ' +
  'the same package but\n// different file) to verify that embedding works ' +
  'in all these scenarios.',
  embeds: [{
    name: 'Trigonometry',
    pkgPath: 'v.io/core/veyron2/vdl/testdata/arith',
    doc: '// Trigonometry is an interface that specifies a couple ' +
    'trigonometric functions.'
  }, {
    name: 'Exp',
    pkgPath: 'v.io/core/veyron2/vdl/testdata/arith/exp',
    doc: ''
  }, ],
  methods: [


    {
      name: 'Sine',
      doc: '',
      inArgs: [{
        name: 'angle',
        doc: '',
        type: vom.Types.FLOAT64
      }, ],
      outArgs: [{
        name: '',
        doc: '',
        type: vom.Types.FLOAT64
      }, {
        name: '',
        doc: '',
        type: _type1
      }, ],
      inStream: null,
      outStream: null,
      tags: []
    },


    {
      name: 'Cosine',
      doc: '',
      inArgs: [{
        name: 'angle',
        doc: '',
        type: vom.Types.FLOAT64
      }, ],
      outArgs: [{
        name: '',
        doc: '',
        type: vom.Types.FLOAT64
      }, {
        name: '',
        doc: '',
        type: _type1
      }, ],
      inStream: null,
      outStream: null,
      tags: []
    },


    {
      name: 'Exp',
      doc: '',
      inArgs: [{
        name: 'x',
        doc: '',
        type: vom.Types.FLOAT64
      }, ],
      outArgs: [{
        name: '',
        doc: '',
        type: vom.Types.FLOAT64
      }, {
        name: '',
        doc: '',
        type: _type1
      }, ],
      inStream: null,
      outStream: null,
      tags: []
    },

  ]
};

test('correct service description', function(assert) {
  var arith = require(
    '../../src/v.io/core/veyron2/vdl/testdata/arith/arith');
  var description = (new arith.AdvancedMath())._serviceDescription;
  assert.deepEqual(description, expectedAdvancedMathDescription,
    'service description matches expectation');
  assert.end();
});