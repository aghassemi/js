/**
 * @fileoverview Helpers for manipulating veyron names.
 */

'use strict';

var _numInitialSlashes = function(s) {
  for (var i = 0; i < s.length; i++) {
    if (s.charAt(i) !== '/') {
      return i;
    }
  }
  return s.length;
};
var _numTailSlashes = function(s) {
  for (var i = s.length - 1; i >= 0; i--) {
    if (s.charAt(i) !== '/') {
      return s.length - 1 - i;
    }
  }
  return s.length;
};


var _removeInitialSlashes = function(s) {
  return s.replace(/^\/*/g, '');
};
var _removeTailSlashes = function(s) {
  return s.replace(/\/*$/g, '');
};

var _joinNamePartsOnArray = function(parts) {
  if (parts.length === 0) {
    return '';
  }

  var name = parts[0];
  for (var i = 1; i < parts.length; i++) {
    var addedPart = parts[i];

    var numNameSlashes = _numTailSlashes(name);
    var numAddedPartSlashes = _numInitialSlashes(addedPart);

    if (numNameSlashes === 0 && numAddedPartSlashes === 0) {
      name += '/' + addedPart;
      continue;
    }

    if (numAddedPartSlashes > numNameSlashes) {
      name = _removeTailSlashes(name);
      name += addedPart;
    } else {
      name += _removeInitialSlashes(addedPart);
    }
  }

  return name;
};

/**
 * Joins parts of a name into a whole.
 * It preserves the rootedness and terminality of the name components.
 * Examples:
 * join(['a, b']) -> 'a/b'
 * join('/a/b/', '//d') -> '/a/b//d'
 * join('//a/b', 'c/') -> '//a/b/c/'
 * @param {array | varargs} Either a single array that contains the strings
 * to join or a variable number of string arguments that will be joined.
 * @return {string} A joined string
 */
var join = function(parts) {
  if (Array.isArray(parts)) {
    return _joinNamePartsOnArray(parts);
  }
  return _joinNamePartsOnArray(Array.prototype.slice.call(arguments));
};

/**
  * Determines if a name is rooted, that is beginning with a single '/'.
  * @param {string} The veyron name.
  * @return {boolean} True if the name is rooted, false otherwise.
  */
var _isRooted = function(name) {
  return _numInitialSlashes(name) === 1;
};

/**
  * Determines if a name is terminal, meaning that it corresponds to a final
  * endpoint and name and does not need to be resolved further.
  * @param {string} The veyron name.
  * @return {boolean} True if the name is a terminal name, false otherwise.
  */
var _isTerminal = function(name) {
  var numInitialSlashes = _numInitialSlashes(name);
  if (numInitialSlashes >= 2) {
    // If the name begins with '//', it is terminal.
    return true;
  } else if (numInitialSlashes === 1) {
    // If the name begins with a single slash, it is terminal if there are no
    // more slashes (indexOf === -1) or if the next slash is a double slash.
    var nextSlashIndex = name.substr(1).indexOf('/');
    var nextDoubleSlashIndex = name.substr(1).indexOf('//');
    return nextSlashIndex === nextDoubleSlashIndex;
  } else {
    // If there are no initial slashes, it is only terminal if it is the empty
    // string.
    return name.length === 0;
  }
};

/**
  * Converts a veyron name to a terminal name. This is used to generate a final
  * name when a name has finished resolving.
  * @param {string} The initial veyron name.
  * @return {string} A terminal veyron name.
  */
var _convertToTerminalName = function(name) {
  // '' -> '' and '/' -> ''
  if (name === '' || name === '/') {
    return '';
  }

  if (_isRooted(name)) {
    if (name.substr(1).indexOf('/') === -1) {
      // '/endpoint' -> '/endpoint'
      return name;
    }
    if (name.substr(1).indexOf('/') === name.length - 2) {
      // '/endpoint/' -> '/endpoint'
      return name.substring(0, name.length - 1);
    }
    // '/endpoint/something' -> '/endpoint//something'
    // '/endpoint//something -> '/endpoint//something'
    return name.replace(/^(\/[^/]+?)[/]*\//, '$1//');
  } else {
    // '/////something' -> '//something'
    return '//' + _removeInitialSlashes(name);
  }
};

module.exports = {
  join: join,
  _isTerminal: _isTerminal,
  _isRooted: _isRooted,
  _convertToTerminalName: _convertToTerminalName
};