/**
 *  @fileoverview Server allows creation of services that can be invoked
 *  remotely via RPCs.
 *
 *  Usage:
 *  var videoService = {
 *    play: {
 *      // Play video
 *    }
 *  };
 *
 *  var s = new server(proxyConnection);
 *  s.serve('mymedia/video', videoService);
 */

var Deferred = require('./../lib/deferred');
var IdlHelper = require('./../idl/idl');
var vError = require('./../lib/verror');
var ServiceWrapper = IdlHelper.ServiceWrapper;

var nextServerID = 1; // The ID for the next server.

/**
 * represents a veyron server which allows registration of services that can be
 * invoked remotely via RPCs.
 * @constructor
 * @param {Object} router the server router.
 */
function Server(router) {
  if (!(this instanceof Server)) {
    return new Server(router);
  }

  this._router = router;
  this.id = nextServerID++;
  this.serviceObject = null;
  this._knownServiceDefinitions = {};
}

/**
 * addIDL adds an IDL file to the set of definitions known by the server.
 * Services defined in IDL files passed into this method can be used to
 * describe the interface exported by a serviceObject passed into register.
 * @param {object} updates the output of the vdl tool on an idl.
 */
Server.prototype.addIDL = function(updates) {
  var prefix = updates.package;
  for (var key in updates) {
    if (key[0] === key[0].toUpperCase() && updates.hasOwnProperty(key)) {
      this._knownServiceDefinitions[prefix + '.' + key] = updates[key];
    }
  }
};

// Returns an error if the validation of metadata failed.
Server.prototype._getAndValidateMetadata = function(serviceObject,
    serviceMetadata) {
  var shouldCheckDefinition = false;
  if (typeof(serviceMetadata) === 'string') {
    serviceMetadata = [serviceMetadata];
  }

  if (Array.isArray(serviceMetadata)) {
    shouldCheckDefinition = true;
    var serviceDefinitions = {};

    for (var i = 0; i < serviceMetadata.length; i++) {
      var key = serviceMetadata[i];
      var object = this._knownServiceDefinitions[key];
      if (!object) {
        return new vError.NoExistError('unknown service ' + key);
      }
      // Merge the results into the single definitions object.
      for (var k in object) {
        if (object.hasOwnProperty(k)) {
          serviceDefinitions[k] = object[k];
        }
      }
    }
    serviceMetadata = serviceDefinitions;
  }

  var wrapper = new ServiceWrapper(serviceObject, serviceMetadata);

  if (shouldCheckDefinition) {
    var err2 = wrapper.validate(serviceMetadata);
    if (err2) {
      return err2;
    }
  }

  this.serviceObject = wrapper;

  return null;
};

/**
 * Serve serves the given service object under the given name.  It will
 * register them with the mount table and maintain that registration so long
 * as the stop() method has not been called.  The name determines where
 * in the mount table's name tree the new services will appear.
 *
 * To serve names of the form "mymedia/*" make the calls:
 * serve("mymedia", myService);

 * serve may be called multiple times to serve the same service under
 * multiple names.  If different objects are given on the different calls
 * it is considered an error.
 *
 * @param {string} name Name to serve under
 * @param {Object} serviceObject service object to serve
 * @param {*} serviceMetadata if provided a set of metadata for functions
 * in the service (such as number of return values).  It could either be
 * passed in as a properties object or a string that is the name of a
 * service that was defined in the idl files that the server knows about.
 * @param {function} callback if provided, the function will be called on
 * completion. The only argument is an error if there was one.
 * @return {Promise} Promise to be called when serve completes or fails
 * the endpoint address of the server will be returned as the value of promise
 */
Server.prototype.serve = function(name, serviceObject,
    serviceMetadata, callback) {
  if (!callback && typeof(serviceMetadata) === 'function') {
    callback = serviceMetadata;
    serviceMetadata = null;
  }

  var err = this._getAndValidateMetadata(serviceObject, serviceMetadata);
  if (err) {
    var def = new Deferred(callback);
    def.reject(err);
    return def.promise;
  }

  return this._router.serve(name, this, callback);
};

/**
 * Stop gracefully stops all services on this Server.
 * New calls are rejected, but any in-flight calls are allowed to complete.
 * All published named are unmounted.
 * @param {function} callback if provided, the function will be called on
 * completion. The only argument is an error if there was one.
 * @return {Promise} Promise to be called when stop service completes or fails
 */
Server.prototype.stop = function(callback) {
  return this._router.stopServer(this, callback);
};

/**
 * Generates an IDL wire description for all the registered services
 * @return {Object.<string, Object>} map from service name to idl wire
 * description
 */
Server.prototype.generateIdlWireDescription = function() {
  return IdlHelper.generateIdlWireDescription(this.serviceObject);
};

/**
 * Export the module
 */
module.exports = Server;
