/**
 *  @fileoverview Client for the veyron service.
 *
 *  Usage:
 *  var cl = new client(proxyConnection);
 *  var service = cl.bindTo('EndpointAddress', 'ServiceName');
 *  resultPromise = service.MethodName(arg);
 */

'use strict';

var Deferred = require('../lib/deferred');
var Promise = require('../lib/promise');
var vLog = require('../lib/vlog');

/**
 * Client for the veyron service.
 * @constructor
 * @param {Object} proxyConnection Veyron proxy client
 */
var client = function(proxyConnection) {
  this._proxyConnection = proxyConnection;
};

/**
 * Performs client side binding of a remote service to a native javascript
 * stub object.
 * @param {string} name the veyron name of the service to bind to.
 * @param {object} optServiceSignature if set, javascript signature of methods
 * available in the remote service.
 * @param {function} [callback] if given, this function will be called on
 * completion of the bind.  The first argument will be an error if there is
 * one, and the second argument is an object with methods that perform rpcs to
 * service
 * methods.
 * @return {Promise} An object with methods that perform rpcs to service methods
 */
client.prototype.bindTo = function(name, optServiceSignature, callback) {
  var self = this;
  if (typeof(optServiceSignature) === 'function') {
    callback = optServiceSignature;
    optServiceSignature = undefined;
  }

  var def = new Deferred(callback);
  var serviceSignaturePromise;

  if (optServiceSignature !== undefined) {
    serviceSignaturePromise = Promise.resolve(optServiceSignature);
  } else {
    vLog.debug('Requesting service signature for:', name);
    serviceSignaturePromise = self._proxyConnection.getServiceSignature(name);
  }

  var promise = def.promise;
  serviceSignaturePromise.then(function(serviceSignature) {
    vLog.debug('Received signature for:', name, serviceSignature);
    var boundObject = {};
    var bindMethod = function(methodName) {
      var methodInfo = serviceSignature[methodName];
      var numOutParams = methodInfo.numOutArgs;
      boundObject[methodName] = function() {
        var args = Array.prototype.slice.call(arguments, 0);
        var cb = null;
        if (args.length === methodInfo.inArgs.length + 1) {
          cb = args[args.length - 1];
          args = args.slice(0, methodInfo.inArgs.length);
        }
        if (args.length !== methodInfo.inArgs.length) {
          throw new Error('Invalid number of arguments to "' +
            methodName + '". Expected ' + methodInfo.inArgs.length +
            ' but there were ' + args.length);
        }
        return self._proxyConnection.promiseInvokeMethod(
          name, methodName, args, numOutParams,
          methodInfo.isStreaming || false, cb);
      };
    };

    for (var methodName in serviceSignature) {
      if (serviceSignature.hasOwnProperty(methodName)) {
        bindMethod(methodName);
      }
    }

    def.resolve(boundObject);
  }).catch (def.reject);

  return promise;
};

/**
 * Export the module
 */
module.exports = client;
